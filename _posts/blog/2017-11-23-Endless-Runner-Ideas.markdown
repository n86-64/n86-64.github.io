---
layout: post
title:  "Endless Running"
date:   2017-11-23 17:00:00
author: Nathan Butt
categories:
- Low Level Programming
- C++
- Games programming
- Software Design
- Developer Dairy
- Endless Runner
img: jetpack_joyride.jpg
thumb: running2.gif
published: true
---

With Snake now finished my attention has turned to my next LLP assignment.
This time around I have to create an endless runner game where the player has to try and dodge all of the obstacles in there way. The main goal of course being to get the highest score possible.

The game can take any form providing:
- The player is continuously running
- The game level is procedurally generated.

With this in mind I began to consider various aspects of the game both technical and mechanical.

<!--more-->

# Initial ideas
In terms of core mechanics a number of different approaches came to mind. Many of these approaches were inspired by other similar games on the market and as a result I began to consider several approaches:
These being:
- A typical endless runner game where obstacles and powerups are generated and the player is required to either collect the items or dodge the obstacles. Similar to games such as [Jetpack joyride](https://youtu.be/OBWtXm1_a6U?t=51s), temple run etc.
- A rhythm based endless runner based of [vib ribbon](https://youtu.be/agr2CaQWUyY?t=28s) where the obstacles are generated according to music properties and the player as to press a button or manoeuvre according to the said obstacles.
- A generated level endless runner where the player has to manoeuvre a static level which is generated by a procedural generated algorithm. Similar to a game called [speedrunners](https://www.youtube.com/watch?v=_Di8gECOHcE) except with procedural generation applied instead of prebuilt levels.

After considering multiple options I decided to go with the first option as this would keep the implementation simple and allow for flexibility for extra gameplay components. However I intend to mix this approach with the second idea and if I do have time I may consider extending functionality to implement this rhythm mechanic as this could add some interesting substance to the gameplay as well as providing a strong twist to the mechanics of an endless runner.

# Technical considerations
For this application I intend to use a similar codebase and object pattern to the my snake application with a few modifications in the form of optimisations. These include improvements to the collision system and object management systems, which were not perfectly optimal in snake and will need some adjustments. This will be done via making the system more data driven as this would reduce processing overhead and improve performance.

Alongside these changes I will also be adding some new components such as UI and input components which will manage user interaction with the game.

## Game Mechanics
Currently I have a few ideas on how to manage various aspects of game mechanic implementation. For starters many of the key elements that comprise this game such as collision I have previously implemented in snake. Hence all that needs to be done is a bit of refining and improving and the same algorithm can be used. Like with snake I intend to use a hitbox algorithm as this provides simple and efficient mechanism for testing collisions which will be key for this game type.

In actuality, the most significant component that will require the most planning is the algorithm for the procedural generation of the level. My current developing solution is to use an 'inheritance' like approach where the child objects that are spawned are based on the parent objects that have already been spawned.

{: .box-note }
In essence the next segment to be generated is based on the previous one.

Hence whilst there is randomness, this procedure would prevent the generation of impossible platforms and allow us to control the difficulty of the runner. Whilst this is currently basic I intend to develop the algorithm to account for these variables as well as other environmental factors.

I hope to soon have a fully fledged plan with all the components fully realised and a implementation started. But in the mean time my focus is to hit the ground running and to get this program implemented.
