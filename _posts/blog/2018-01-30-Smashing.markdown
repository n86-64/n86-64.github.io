---
layout: post
title:  "Smashing System"
date:   2018-02-07 23:00:00
author: Nathan Butt
categories:
- Game Engine Programming
- C++
- Game Engines
img: supersmash.jpg
thumb: ssb.jpg
published: true
---

My university studies have very much begun and with that I have been given one of my first assignments. This assignment is part of my GEP or Game Engine Programming module and requires us to produce a small-scale game engine based on a pre-existing game which is selected by our lecturer.

<!--more-->

## The game

As the title implies, the game that we were given was Super Smash Bros. Incase you don't know, Super Smash Bros. or SSB is a 4/8-player arena 2.5D fighting game produced by Nintendo. The main objective of the game is to knock your opponents out of the arena. No prizes for guessing that this is done via punching, kicking and using items. Once you have built up enough damage against an opponent you are then able to use a smash attack and knock them out of the arena with damage being proportional to the momentum that the player receives from an attack.

Whilst a seemingly simple game there are a lot of hidden complexities and subtle nuances to the game which is why today it is considered one of the most popular fighting games in the world amassing an infamous reputation in the fighting game community.

The game comes with a variety of game modes from Timed battles to stocks/lives.

<iframe width="560" height="315" src="https://www.youtube.com/embed/k2izw5VJNfg?start=67&end=214" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>

<p>Smash Bros WII U Gameplay (Curtosey of ZackScottGames)</p>

## The Assignment

The assessment is in essence designed to emulate a typical software development process for a game engine. Each individual is allocated a team within the module and the said team has to produce the said engine. I was allocated onto a team with three other individuals and immediately set about working with my team members to get a plan of action together.

The assessment has two major stages, a concept stage and a production stage. The planning stage involves the creation of a basic "throwaway" prototype of the game with the production stage being the development and final release of the engine for our game.
Hence our goal at the moment is to create a basic SSB prototype as well as get all the paperwork together for our submission.

Whilst the developed prototype will not be used directly or released, it will still be very useful in allowing me and the team to work out a basic structure for the game. These structures and routines can then be transferred into the final project and further refined to allow us to create a well-rounded game which is both enjoyable and functional.

## The Prototype

After approximately three weeks of development me and my team were able to create a basic prototype.
This prototype contained many key SSB mechanics such as character selection, map selection and basic combat. The prototype allowed up to 4 players to connect their controllers and play through a selection of 3 levels which could be selected through the character selection screen.  

![demo1](https://n86-64.github.io/assets/img/blog/GEP/protodemo1.gif)
![demo2](https://n86-64.github.io/assets/img/blog/GEP/protodemo2.gif)
![demo3](https://n86-64.github.io/assets/img/blog/GEP/protodemo3.gif)

The prototype was successful in several ways, such as allowing for the creation of custom gamemodes and allowing for custom configurable characters. Users could also use both the keyboard and controllers to move the characters around on screen and they were able to fight each other with a basic SSB-like combat system. This meant that upon being punched the players would be sent in the said direction of attack according to the damage they received.

However, the prototype did have significant limitations and bugs which mostly affected movement and momentum in the game. These bugs were the result of both problems with source control organisation which would be an issue when managing the input manager for example, as well as certain methods that we had used in capturing input. The prototype also didn't contain a number of elements such as the ability to temporarily disable physics collisions for players allowing them to fall through platforms.

In order to create the prototype each of us assigned ourselves a role focusing on one particular area of the program.

My role was to create the UI components, and the 'game mode' system which would allow for custom game modes and custom game settings for each session. The UI system comprised of the main menu and an in-game UI that would display the current time and health of the player. The gamemode system which would allow for overriden behaviour, allowing custom objectives and scoring systems to be used. This also included a mechanism for providing player information allowing players to be spawned and input to be mapped.


## What we learned

The development of this prototype allowed us to get a clear insight into the components that we require for our engine. During development due to various factors we encountered a number of issues.

One notable issue we had was to do with input. Input in Unity for controllers is handled via separate input entries which are then mapped to individual joysticks. This resulted in excessive redundancy as we would have to keep entering new input fields for the other players. Hence our team intends to create a more robust input server/manager which can eliminate this redundancy via having common input mapping which can then either be retrieved from individual controllers or all controllers.

We also encountered issues with the repository when it came to merging the project together. This was the result of code divergence in the project in areas such as input management. Hence when it came to merging, it resulted in a number of conflicts which in tern led to data loss in effect. Also, we had no scheme for merging into the development branch with each of us merging as needed. But this resulted in merge conflicts. So, when it comes to the engine we are going to be spending more time in the planning phase agreeing both a standard and a pull request system. Pull requests are a feature of git which in essence notifies the developers the intention to merge. This way the group and I can review changes and ensure they don't break as well as allow us to update our development branches before starting a project.


## Whats next

Now that the prototype has been finished we will be having various SCRUM meetings over the next week to discuss the direction of the engine. Our primary focus will be on planning development of the engine from the engine structure and documentation, to organising the project management structure.

This stage should be completed relatively quickly and will then allow us to commence development of the engine itself. Creating each component class by class.
